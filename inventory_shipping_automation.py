# -*- coding: utf-8 -*-
"""Inventory shipping automation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AFGlfCRiHPcK7OnrlXY72vHR0nuoW8ML
"""

# code to automate requirement calculations and shipping to different branches, which will receive a number of products from different distribution centers,
# based on the needs of every branch and the availability of products in the distribution centers.

# column names will be on portuguese, and personal/company information will be hidden.

# import all librarys:

from google.colab import auth
from google.cloud import bigquery
from google.colab import data_table
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
import smtplib
import pandas as pd
import numpy as np
from datetime import datetime
import math

data = datetime.today().date()
data_hoje = str(data) # current date.


project = 'project' # Project ID inserted based on the query results selected to explore
location = 'US' # Location inserted based on the query results selected to explore
client = bigquery.Client(project=project, location=location)
data_table.enable_dataframe_formatter()
auth.authenticate_user()

# SQL query:
query = """
WITH

BASE_RUPTURA AS (

SELECT DISTINCT
GEMEO,
IBM AS COD_IBM,
GEMCO,
DESCRICAO,
FILIAL AS COD_FILIAL,
STATUS_BLOQUEIO,
CD,
QTDE_DISPONIVEL_LOJA as ESTOQUE_LOJA,
QTDE_TRANSITO_LOJA as TRANSITO_LOJA,
QTDE_DISPONIVEL_CD AS ESTOQUE_CD,
QTDE_TRANSITO_CD AS TRANSITO_CD,
DIRETORIA,
LINHA,
FAMILIA,
CODSITPROD AS SITUACAO_PRODUTO,
FORNECEDOR,
VLR_CMUP AS CMUP,
SORT_ABA AS HAS_ABA,
SORT_PORTAL AS HAS_PORTAL,
TRONCO_COMUM,
VMD_LOJA,
VMD_CD,
(VMD_LOJA * 7) AS DEMANDA_7,
(VMD_LOJA * 30) AS DEMANDA_30,
DT_ATUALIZACAO
FROM `base_1`),

BASE AS(

SELECT DISTINCT *,
(CASE WHEN B.PEX2 IS NULL THEN C.Pex3 ELSE B.PEX2 END) AS Pex_Final
FROM BASE_RUPTURA

LEFT JOIN (
SELECT Pex as Pex2,
Product,
Branch
FROM base_2) AS B ON CAST(cod_ibm AS INT64) = CAST(B.Product AS INT64) AND CAST(B.Branch AS INT64) = CAST(cod_filial AS INT64)

LEFT JOIN (
SELECT
Pex as Pex3,
Product,
FROM base_2
WHERE Branch IS NULL)
AS C ON CAST(BASE_RUPTURA.cod_ibm AS INT64) = CAST(C.Product AS INT64))

SELECT DISTINCT
GEMEO, -- Twin code.
base.cod_ibm AS IBM, -- Product code.
DESCRICAO, -- Product description.
LINHA,
FAMILIA,
FORNECEDOR,
COD_FILIAL AS FILIAL, -- Branch code.
STATUS_BLOQUEIO, -- Branch status.
CD, -- Distribution center.
ESTOQUE_LOJA, -- Branch stock.
TRANSITO_LOJA, -- Branch transit.
ESTOQUE_CD, -- Distribution center stock.
TRANSITO_CD, -- Distribution center transit.
HAS_ABA, -- Product eligibility in each branch.
SITUACAO_PRODUTO, -- Product status.
VMD_LOJA, -- Branch average daily sale.
VMD_CD,-- Distribution center average daily sale.
ROUND((BASE.VMD_LOJA * 7),0) AS DEMANDA_7, -- Branch demand 7 days.
ROUND((BASE.VMD_LOJA * 30),0) AS DEMANDA_30,-- Branch demand 30 days.
COALESCE(CAST(ROUND((PEX_FINAL),0) AS INT64),0) AS PEX, -- Branch exposure need.
CAST(ROUND(BASE.PEX_FINAL + (BASE.VMD_LOJA * 7),0) AS INT64) AS PEX_DEMANDA_7, -- PEX + demand 7 days.
CAST(ROUND(GREATEST((BASE.PEX_FINAL - BASE.ESTOQUE_LOJA - BASE.TRANSITO_LOJA),0),0) AS INT64) AS FALTA_PEX, -- PEX - Stock - Transit = Necessity.
CAST(ROUND(GREATEST((BASE.PEX_FINAL + (BASE.VMD_LOJA * 7) - BASE.ESTOQUE_LOJA - BASE.TRANSITO_LOJA),0),0) AS INT64) AS FALTA_PEX_DEMANDA_7,
COALESCE(`maga-bigdata.abastecimento.productdimension`.SupplyPack, 1) as CAIXA_ABA, -- Quantity of products in a closed box.
ROUND(GREATEST((ESTOQUE_CD - (VMD_CD * 15)),0),0) AS DISPONIVEL_CD, -- Protecting 15 days of distribution center sales. Nothing will be sent beyond this protection.
FROM BASE

LEFT JOIN base_3 ON CAST(base_3.IBMcode AS INT64) = CAST(base.cod_ibm  AS INT64)

WHERE LINHA = "UD - UTILIDADES DOMESTICAS" AND DT_ATUALIZACAO = "2023-08-15" -- Filter current date and category to be analyzed.
AND STATUS_BLOQUEIO <> "FEC" AND STATUS_BLOQUEIO <> "FECA" -- Exclude closed branchs.
ORDER BY ESTOQUE_LOJA DESC -- Branch with less stock will be prioritized on product apportionment.

"""

# read query:
query_job = client.query(query)
results = query_job.result()

# select column names:
column_names = [field.name for field in results.schema]

# convert on csv file with no calculations:
filename = "ruptura_loja.csv"
with open(filename, "w") as f:
  f.write(";".join(column_names) + "\n")

  for row in results:
    f.write(";".join([str(row[field.name]) for field in results.schema]) + "\n")

# csv to data frame:
df = pd.read_csv(filename, sep=";")

# number of products, branchs and distribution centers:
CODIGOS_count = len(df['IBM'].unique())
FILIAIS_count = len(df['FILIAL'].unique())
CDS_count = len(df['CD'].unique())

print(
    "Distinct products count:", CODIGOS_count,
    "\nDistinct branches count:", FILIAIS_count,
    "\nDistinct CDs count:", CDS_count)

df.head()

df.info()

# define function that will be used to round to closed box multiples.
def teto(numero1, numero2):
    return math.ceil(numero1 / numero2) * numero2

# boxes with zero can be replaced by one.
df['CAIXA_ABA'] = df['CAIXA_ABA'].replace(0, 1)

# calculate branch inventory by twins (similar products). If branch has the similar product, should not receive another one.
df["ESTOQUE_GEMEO"] = df.apply(lambda row: df.loc[(df["FILIAL"] == row["FILIAL"]) & (df["GEMEO"] == row["GEMEO"]), "ESTOQUE_LOJA"].sum(), axis=1)

# similar products transit:
df["TRANSITO_GEMEO"] = df.apply(lambda row: df.loc[(df["FILIAL"] == row["FILIAL"]) & (df["GEMEO"] == row["GEMEO"]), "TRANSITO_LOJA"].sum(), axis=1)

# shipping requirement only where the product is eligible on branch:
df["NECESSIDADE_ENVIO"] = np.where(
    df["HAS_ABA"] == 1,
    np.maximum(df["PEX"] + df["DEMANDA_7"] - df["ESTOQUE_GEMEO"] - df["TRANSITO_GEMEO"], 0),
    0)

# distribuiton center total necessity on each product:
df["NECESSIDADE_TOTAL_CD"] = df.apply(lambda row: df.loc[(df["CD"] == row["CD"]) & (df["IBM"] == row["IBM"]), "NECESSIDADE_ENVIO"].sum(), axis=1)

# adjust branch requirement based on total distribution center requirement:
def calcular_falta_ajustada(row):
    falta_ajustada = 0

    if row["NECESSIDADE_TOTAL_CD"] != 0:
        falta_ajustada = np.minimum(
            math.ceil(
                np.nan_to_num(row["NECESSIDADE_ENVIO"] * (row["DISPONIVEL_CD"] / row["NECESSIDADE_TOTAL_CD"]), nan=0)
            ),
            row["NECESSIDADE_ENVIO"]
        )

# if division by zero:
    else:
        falta_ajustada = 0

    return falta_ajustada

df["NECESSIDADE_AJUSTADA"] = df.apply(calcular_falta_ajustada, axis=1)

# round to box size.
for index, row in df.iterrows():
    df.at[index, "NECESSIDADE_AJUSTADA_ABA"] = teto(row["NECESSIDADE_AJUSTADA"], row["CAIXA_ABA"])

# calculate the first shipment:
def fazer_rateio(row):
    soma_condicional = df[
        (df["IBM"] == row["IBM"]) & (df["CD"] == row["CD"]) &
        (df.index <= row.name)
    ]["NECESSIDADE_AJUSTADA_ABA"].sum()

# if the disponibility on distribution center ends:
    if soma_condicional > row["DISPONIVEL_CD"]:
        return 0
# if there is still disponibility:
    else:
        return row["NECESSIDADE_AJUSTADA_ABA"]

df["ENVIO_1"] = df.apply(fazer_rateio, axis=1)

# necessity that could not be sent due to disponibility:
# main product could not be sent, calculate the similar product disponibility to replace it:
df["SALDO"] = np.maximum(df["NECESSIDADE_ENVIO"] - df["ENVIO_1"] ,0)

# remaining stock on distribution center (after first sent):
df["DISPONIVEL_CD_2"] = df["DISPONIVEL_CD"] - (df.apply(lambda row: df.loc[(df["CD"] == row["CD"]) & (df["IBM"] == row["IBM"]), "ENVIO_1"].sum(), axis=1))

# total fault by branch row:
df["SALTO_TOTAL"] = df.apply(lambda row: df.loc[(df["FILIAL"] == row["FILIAL"]) & (df["GEMEO"] == row["GEMEO"]), "SALDO"].sum(), axis=1)
# number of similar products on branch row:
df["COUNT_GEMEO"] = df.apply(lambda row: df.loc[(df["FILIAL"] == row["FILIAL"]) & (df["GEMEO"] == row["GEMEO"]), "SALDO"].count(), axis=1)

# divide by number of similar products:
try:
    df["NECESSIDADE_ENVIO_2"] = np.ceil(df["SALTO_TOTAL"] / df["COUNT_GEMEO"])
# in case of division by zero:
except (ZeroDivisionError, ValueError):
    df["NECESSIDADE_ENVIO_2"] = 0

# total fault by distribution center:
df["NECESSIDADE_TOTAL_CD_2"] = df.apply(lambda row: df.loc[(df["CD"] == row["CD"]) & (df["GEMEO"] == row["GEMEO"]), "SALDO"].sum(), axis=1)

# adjust branch fault based on total distribution center fault:
def calcular_falta_ajustada_gemeo(row):
    falta_ajustada_gemeo = 0

    if row["NECESSIDADE_TOTAL_CD_2"] != 0:
        falta_ajustada_gemeo = np.minimum(
            math.ceil(
                np.nan_to_num(row["NECESSIDADE_ENVIO_2"] * (row["DISPONIVEL_CD_2"] / row["NECESSIDADE_TOTAL_CD_2"]), nan=0)
            ),
            row["NECESSIDADE_ENVIO_2"]
        )
    else:
        falta_ajustada_gemeo = 0

    return falta_ajustada_gemeo

df["NECESSIDADE_AJUSTADA_2"] = df.apply(calcular_falta_ajustada_gemeo, axis=1)

# round to box size:
for index, row in df.iterrows():
    df.at[index, "NECESSIDADE_AJUSTADA_ABA_2"] = teto(row["NECESSIDADE_AJUSTADA_2"], row["CAIXA_ABA"])

# calculate second shipment:
def fazer_rateio_2(row):
    soma_condicional = df[
        (df["IBM"] == row["IBM"]) & (df["CD"] == row["CD"]) &
        (df.index <= row.name)
    ]["NECESSIDADE_AJUSTADA_ABA_2"].sum()

    if soma_condicional > row["DISPONIVEL_CD_2"]:
        return 0
    else:
        return row["NECESSIDADE_AJUSTADA_ABA_2"]

df["ENVIO_2"] = df.apply(fazer_rateio_2, axis=1)

# final shipment:
df["ENVIO_FINAL"] = df["ENVIO_1"] + df["ENVIO_2"]

# drop aux columns:
df = df.drop(["SALTO_TOTAL", "COUNT_GEMEO"], axis=1)

# sort by final send:
df.sort_values(by=["ENVIO_FINAL"], ascending=[False], inplace=True)

df.head()

df.info()

# convert final data frame to csv file:
df.to_excel("Ruptura_envio.xlsx", index=False)

print("Calculations completed successfully!")

# send file automatically by email:
sender_email = "example_email@hotmail.com.br"
receiver_email = "example_email_2@hotmail.com.br"
subject = "Inventory shipping - " + data_hoje

msg = MIMEMultipart()
msg["Subject"] = subject
msg["From"] = sender_email
msg["To"] = receiver_email

body = "Good morning! \nFollow product shipping analysis."
msg.attach(MIMEText(body, "plain"))

with open(filename, "rb") as f:
  attach = MIMEApplication(f.read(), _subtype="csv")
  attach.add_header("Content-Disposition", "attachment", filename=filename)
  msg.attach(attach)

smtp_server = "smtp.gmail.com"
smtp_port = 587
smtp_username = "example_email@hotmail.com.br"
smtp_password = "password"

server = smtplib.SMTP(smtp_server, smtp_port)
server.starttls()
server.login(smtp_username, smtp_password)
server.sendmail(sender_email, receiver_email, msg.as_string())
server.quit()

print("Email successfully sent!")